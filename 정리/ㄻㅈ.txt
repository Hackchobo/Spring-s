
    private 멤버필드에 값을 대입하고 추출. 하는방법
    <값 주입>
    1. 생성자 통해서 -- 상속처럼 값이 변하지않는다.
    2. setter 메소드 통해서
    <값 추출>
    1.getter 메소드 통해서

// getter은 반환형에 get으로 한다. ex)getName(){}
 // this.은 생략 가능하다.

//세터는 무조건 보이드를 사용하고 타입은 무조건 private를 따르며 네임도 똑같이 해준다. 멤버필드의 이름을 사용하려면 this를 이용하여야한다.
//  카멜케이스 기법으로 만들어 주어야 한다.

// 자식타입은 부모 객체 주소값 저장할 수 없다.
    //레퍼런스 변수들끼리 형변환이 가능할땐 상속관계일때만 된다.
   // 메소드는 객체기준이라서 자식부터 찾고 그다음에 부모필드를 찾아간다.

// 형변환이 가능한지 판별해주려면 instanceof 를 사용하면 된다.
//클래스에는 default아니면 public을 준다. public은 완전한 공유가 가능하다. 심지어 클래스가 달라도 가능 public은 어떻게 사용 가능하냐
    // class dd {} <- default 클래스 사용을 잘 안한다.
제어자는 클래스 멤버변수 메서드 
접근제어자 (P.348)
        private int num1;  // 같은 클래스 내부에서는 사용 가능 멤버필드면 private사용을 한다.
        int num2;          // 같은 패키지안에서만 사용가능하다. default
        protected  int num3; // 이걸 사용 하게 될경우 실력이 많이 늘어 난것이다.  상속관계에서 사용가능, 같은 패키지, 같은 클래스
        public  int num4;      // 완전 공유가 가능  상수만 public 준다.


 다형성 - 상속관계에서만 의미있음(P.354)

        1. 부모타입은 자식 객체 주소값 저장할 수 있다.
        2. 자식타입은 부모 객체 주소값 저장할 수 없다.
        3. 타입은 (알고 있는 메소드만 호출할 수 있음)
                 (메소드를 호출할 수 있나없나만 결정)
                 >> 실제로 실행되는 건 객체 기준이다.
 기본생성자가 있으면 각자 지역변수에 super(OOO)을 안해 줘도 된다.

오버로딩 - 이름을 안맞춰도 상관 없다.
오버 라이딩 - 무조건 이름을 똑같이 맞춰줘야 한다.