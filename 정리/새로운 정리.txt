4/27
자바에서 패키지(package)란 클래스와 인터페이스의 집합을 의미합니다.
패키지를 통해서 라이브러리끼리 구분이 가능합니다.
패키지를 사용하는 이유는 클래스명의 고유성을 보장하기 위함입니다.
패키지를 사용할때 웹도메인을 따른다. 세상에서 유일한 이름이다.

자바가 실행할때는 클래스로 바뀌어서 됨.
주석은 실행될때 무시당하는 부분
값을 나타내주는 코드는 System.out.println() 을 통해서 나타낸다.
콘솔창에 나타내주는것을 스트림이라고 한다.

자바는 JDK, JRE 로 운영이 된다.

String OO = String.format("OOO",age); - format은 실무에서도 자주사용되는 부분이다.

p.75 Casting

역으로 하는것은 문제가된다. ex) 인트에 더블을 넣는것을 하면 안된다. 하지만 더블에 인트는 된다.
플룻과 더블은 지수형태이다. 롱보다 우선순위가 높다.
long 은 8b float는 4b 이다. 
플룻에 롱을 넣는것은 이상하게 된다. 되는이유는 플룻은 값이 크게 저장이 되는것 같지만 정확한 값저장은 불가능.

p.25 ~26 Naming

public class Naming {                       //무조건 파스칼 케이스
//단어 +단어+ 단어

        //Hello World Bye
        //기법
        //파스칼 케이스 기법 > 클래스명
        String HelloWorldBye;

        //카멜 케이스 기법 > 변수명, 메소드명
        String helloWorldBye;

        //스네이크 케이스 기법(자바에서는 잘안씀)
        String hello_world_bye;

        //케밥 케이스 기법(자바에서 못씀)
        //String hello-world-bye;

        //이름에 올수있는 특수기호 2개 : _, $  (_는 문자로 사용)
        String _hi, h$1;

        //이름 처음에 숫자 사용할 수 없다. but 처음만 아니면 된다., 모든 이름에 사용은 다안된다.
        //String 1aa;
        String a1a;

        //이름에 빈칸 사용할 수 없다.
        //Sting hello world; -> String hello_world(이렇게 써야됨)

        //대소문자 구분
        String aaa;
        String aAa;
        String aaA;

        //예약어 사용 금지 (파랑색상 단어는 예약어)
        //String public;
        String pUblic;

        //상수는 전부 대문자, 스네이크 케이스 기법
        final int MY_NUM =13;
        // NUM = 20;

리터럴은 값그자체이고 상수는 한번 입력된 값이 바뀌지않는 값

%d는 변수의 값을 집어넣어 나타내주는 것이다.
%5d , %-5d 는 오른쪽정렬 왼쪽정렬
%c는 문자의 값을 나타내주는 것이다.
%f는 실수의 값을 나타내주는 것이다.
%14.10f <-14자리의 자리를 차지하며 .10 남은 뒷자리는 0으로 맞춘다.
%s는 모든값을 나타내줄수있다.

String r1 = str.substring(0,4); -> .substring은 문자열 자르기에 사용되며 (초기값, 자를 위치)까지를 한다.
스트링객체도 캐릭터배열을 가지고있다. ->return char[ ] items= new char[14];

String r2 = str.indexOf( ); -> .indexOf를 사용하면 내가 찾고싶은 문자열의 번호를 알수가있다. 왼쪽부터 실행이 되는 것이기 때문에 마지막에 쓰인 위치를 알고싶을 때는 lastIndexOf( )사용 해주면 마지막 위치 에서부터 찾는다.
String r1 = str.replace("*","").trim(); -> .replace(없애고싶은 문자, 바뀔문자) .trim(); 은 앞쪽과 뒷쪽의 띄워쓰기를 지워준다.
String[] strArr = str2.split(":"); -> (자르는 기준) 자르는 기준을 기준으로 정리해서 문자열을 나타내준다.
String r2 = str3.toLowerCase(); -> 영문자를 소문자로 바꿔서 나타내준다.
String r3 = str3.toUpperCase(); -> 영문자를 대문자로 바꿔서 나타내준다.

대입연산자가 있어야 값을 변경가능하다.

블린타입은 주로 if문에 쓰인다. 분기문에 많이 사용 됨.

'' <-를 사용하면 문자 하나를 저장할수있다.

//double(8byte) 조금더 정확 하다., float (4byte)

실수는 아주작은 값이라도 더블타입이다.

//리더럴 Literal, 값 그 자체!!
 //byte의 범위는 0~127 까지 이므로 128은 오버플로우 현상이 일어남. 

Byte.MAX_VALUE <- 여기 서 알수있는것은 다대문자라서 상수임을 알수있고, 스택틱인이유는 객체화를 안했기 때문이다.

문자열 더하기는 메모리를 엄청많이 쓴다. 그래서 StringBuilder sb = new StringBuilder(); 를 사용한다.
문자열을 비교할때는 .equals를 사용한다., == 비교는 주소값비교이다.
Object에 있는 equals는 주소값을 비교한다. 단 문자열은 스트링이 참조되어있기때문이다.

instanceof <- 은 형변환이 가능한지 여부를 알아보는것이다.

round(반올림) - 
ceil(올림) -페이징처리를 하였을때 주로 사용된다. ex)게시물이 50개나타내주는 페이지에 51개의 게시물이 있으면 페이지 수를한개 더나와야 되기때문에.
floor(버림) -

// && and 연산자 -----> 모두가 값이 맞아야 true 거짓이 될확률이 높은 값에 사용
        // || or 연산자 -----> 어느것하나라도 맞으면 true 참이 될확률이 높은 값에 사용
        // (2 > 1) && (3>2) true
        // (2 > 1) && (3>2) &&(3>=5) false

3항연산자에서 연산은 왼쪽부터 실행을해서 결과값을 나타낸다. 그러나 먼저 연산을 하고 싶으면( )안에 넣고 돌리면 된다.

3항식 ex) absX = x>=0 ? x: -x; -> 이름 = 조건 ? 참:거짓;

//미만, 초과 <>
        //이하, 이하 <=, =>
!뒤에 올수있는 데이터의 타입은 boolean

break; // 그냥 빠져나오는 것(다수사용) 가장가까운 반복문을 빠져나오는 것
continue; // 스킵이라고 봐도 된다.(사용을 잘안함) 가장 가까운 반복문을 스킵하고 증감식으로 간다.
static이면 클래스명이름이랑 비슷하게 해주어야 한다.

멤버필드는 변수와 상수로 이뤄져있으며 값을 유지시켜준다.

배열: 같은 타입의 여러값을 저장하기 위한 공간
int[] numArr = {10,20,30}; // int[] 형 배열이다. 여러가지 수를 저장할수있는 것 0 ~ 시작 for로 이용 많이함 - 만듬과동시에 변수값을 초기화 시킨것이다.
int numArr2[]= {10,20};  // 차이는 없으나 c에서많이 사용하므로 자바에서는 안씀

프라모티브타입은 디폴트값 0
boolean만들어 가며 기본적으로 false로 나온다.
 String 타입은 디폴트값 null

메소드를 사용하면
int[] arr = {1,2,3};
        printArr(arr);

        printArr(new int[] {1,2,3});  -- 다이렉트로 보낼때

public static void printArr(int[] arr){

    }

쉘로우 카피 - 얕은 복사라고 하고 주소값만 복사하는 것
딥 카피 - 깊은 복사라고 하고 주소값에있는 값을 복사하는 것

// foreach문은 순서대로 nm에 복사가된다. 장점 : 조건식이나 ++안적어도된다. 값만사용할때는 좋다. 값만 읽기 할때는 좋다.
            // 단점 인덱스값을 못쓴다.

포이치문은 for(String nm : names) -> 배열값의 0번째 부터 names의 길이만큼 for문을 돌린다.

선택정렬 - 내림차순은 <- 부분의 방향 만 바꾸면됨`
for (int i = 0; i < selec.length-1; i++) {
            for (int z = i+1; z < selec.length; z++) {
                if(selec[i]<selec[z]){                                   <- 이부분
                    int tmp = selec[i];
                    selec[i] = selec[z];
                    selec[z] = tmp;
                }
            }
        }

버블 정렬 (오름차순) - 내림차순은 <- 부분의 방향 만 바꾸면됨
 for (int i = 0; i < buble.length-1; i++) {
            for (int z = 0; z < buble.length-i-1; z++) {
                if(buble[z] > buble[i]){                                   <- 이부분
                    int tmp = buble[z];
                    buble[z] = buble[z+1];
                    buble[z+1] = tmp;
                }
            }
        }

메소드한테 복사할때는 딥카피는 절대안되며 쉘로우 카피만 된다.

private 멤버필드에 값을 대입하고 추출. 단, 상수만 public을 준다.(변경되지않는 것)
    <값 주입>
    1. 생성자 통해서 -- 상속처럼 값이 변하지않는다.
    2. setter 메소드 통해서

    <값 추출>
    1.getter 메소드 통해서

다형성 - 하나의 객체나 메소드가 여러가지 다른 형태를 가질 수 있는것을 말합니다. 상속관계에서만 이뤄진다. 직속으로 하는것 자식클래스가 부모클래스를 상속받는것 
오버라이딩 - 부모가 갖고있는 메소드를 자식클래스가 사용하는것
오버로딩 - 파라미터만 다르면 똑같은 이름으로 메소드를 만들수있다.
자식 클래스가 부모클래스를 상속받을때 사용하는 단어Extends
클래스가 인터페이스를 상속받을때 인플리먼츠
인터페이스 인터페이스 상속할때는 익스텐즈 사용

 //클래스(class): 붕어빵틀, 설계도
        //객체 (object) : (인스턴스, Instance) 클래스로 만들 실체
        //객체 2가지 구성요소: 멤버필드(변수, 상수), 멤버메소드
        //멤버필드 명사 담당, 값 저장 가능
        //멤버 메소드 동사 담당, 동작 담당.
        //e.g. 게임 캐릭터, 멤버필드 > 직업, 이름, 레벨, HP, MP, 스테미너
        //                    , 멤버메소드 > 이동한다. 아이템 줍는다. 아이템 버린다. 공격한다.

        //Method(메소드),Function(함수)
        //객체안에 존재하면 메소드
        //객체밖에 존재하면 함수

        //stack (FILO) First In Last Out
        //Heap (FIFO) First IN Fitst Out

break -> 그냥 빠져나오는 것(다수사용) 가장가까운 반복문을 빠져나오는 것
continue - > 스킵이라고 봐도 된다.(사용을 잘안함) 가장 가까운 반복문을 스킵하고 증감식으로 간다.

static(객체화가 필요없는 것) - > 클래스안에 없다라고 봐도 무방(스태틱이 사용된메소드는 멤버필드에있는 변수를 사용하지못한다.
스태틱이안붙어 있으면 객체화를 해주어야 한다.

기본생성자가 없으면 컴파일러에서 자동으로 생성해준다. 
클래스 이름 () {
	super();
}
// 임의로정한 네임이지만 선언하는 순간 타입이자 객체의 이름이된다., 사용자 정의 클래스라고 한다.
String color;           //초기값은 null 이다. 대문자로 시작되는대부분의 타입은 null이다.
    boolean power;          // 멤버필드는 주로 위에 적는다.
    int channel;            // 초기값은 0이다.


void power() { power = !power;} // 실행을 한번하였을때 true이다가 다시실행하면 false 다시실행하면 true
    void setChannelUP() { ++channel;}       //메서드
    void channelDown(){--channel;}
        // static을 사용하면 메모리에 무조건 올라간다.
    // 멤버필드에는 사용시 static 사용가능
    void test(String str){
        System.out.println(str);
    }
    static String getBrand(){
        return brand;
    }

다른 클래스를 참조하여 해당 메소드를 사용하는 방법은 . 이다.

배열을 만들때는 타입[ ] tvArr = new 타입[8]; 으로 배열을 만들수있다.

스태틱으로 클래스를 호출하면 1개의 값 밖에 저장을 하지 못한다.또한 이미 메모리에 올라가있는 것이라 객체화할 필요없음(호출할때는 대문자로시작하는 클래스명으로 호출해야 한다.)
인스턴스 멤버필드를 사용하려면 스태틱을 붙일수 없음.

스태틱을 붙이는것을 적극 권장이지만 빨간줄이 뜨면 지우길바람

메소드의 파라미터에는 타입을 하나하나 적어 줘야 된다.

S .out .prin > chainnig 체이닝 기법이라고 한다.

println -> 주소값에 있는 값을 나타내주는 것임, 나를 표현하기 위한 값을 toString을 표현 해준다.
to String 메소드를 호출은 디폴트값임

List 가 부모인터페이스이고 안에 Linked list, ArrayList 가 들어 가있다.

오버로딩이란 똑같은이름의 메소드를 만들수있는 것이다. 리턴타입이랑은 상관없고 받는 타입이 달라야 된다.
가변인자란 static void sum(int... nums) { // int... 은 배열을 하는것이다. 
// 순서가 있으면 for, foreach 문을 사용 할수있다.

// private 접근금지
 // class 안에 있는것은 전역 변수
 // 멤버필드갯수에따라 저장할수있는 정수값 수가 달라진다.

// 프라이빗 값 생성자,setter 메소드를 통해서 값을 넣을수있다. 2.s
// get set 은 get은값을 달라는것 set은값을 셋팅하는것

setter를 사용하여 변경을 해주면 변경되는값을 통제가능하다.

public 을 사용하면 상수이며 static이 붙을가능성 다수

상속관계에서만 다형성이 됨

오버라이딩의 조건은 부모메소드와 이름과 선언부가 같아야 된다.

super. 는 자식 메소드에서 부모메소드를 이용하고 싶을때 사용을 많이 한다.

파일명이랑 같은클래스 앞에만 public을 붙일수있다.

instanceof Object ->항상 트루이기때문에 사용할 필요가 없다.
생성자를 사용하는 이유 - 객체를 생성함과 동시에 초기화하기 위해 셋터를 이용하지않고 값을 집어 넣기위해

//세터는 무조건 보이드를 사용하고 타입은 무조건 private를 따르며 네임도 똑같이 해준다. 멤버필드의 이름을 사용하려면 this를 이용하여야한다.
1. 부모타입은 자식 객체 주소값 저장할 수 있다.
        2. 자식타입은 부모 객체 주소값 저장할 수 없다. ->부모보다 클수밖에 없어서 안된다.
        3. 타입은 (알고 있는 메소드만 호출할 수 있음)
                 (메소드를 호출할 수 있나없나만 결정)
                 >> 실제로 실행되는 건 객체 기준이다.

                 다중상속을 허용하지 않는 이유 - 다중상속을 하였을경우 자식타입의 같은이름을 호추할경우 오류가 발생할수있기 때문이다.
 @Override
    public String toString(){ return "Computer"; } -> 내가 원하는 값을 나타나게해주는 코드!! 중요!!

추상메소드란 선언부만 있는 메소드이다. 사용법은 abstract가 있어야 한다.

// 클래스앞에 abstract를 붙히는게 추상클래스임
    //추상메소드가 있으면 무조건 abstract를 무조건 사용 해줘야됨,없으면 절대 사용가능하지않다.
    //메모리에는 올리고싶은데 객체화가 안되게 하고싶으면 사용함
    // 강제성이 있다. 부모클레스가 강제성이 있다. ex) 무조건 오버라이딩해야함
    // 추상클래스는 무조건 자식클래스가 있다.
    // 기본생성자 앞에 프라이빗을 주면 객체생성을 못하게 할수있다.
    // 추상클래스가 없는 클래스라도 앱스트랙트를 붙일수있다. 하지만 객체화가 불가능해진다.
    // 클래스는 단일상속밖에 안된다. 인터페이스만 다중상속이 가능함
abstract가 없으면 강제성이 없다.
// 인터페이스는 무조건 추상 메소드 이다. 참고로 다중상속이 된다.
// abstract을 안적어 줘도 된다. public이 그냥 적힌다.
인터페이스를 상속할때는 implements 를 사용하면 된다.
인터페이스 는 부모로써만 작동하며 다중상속이 가능하고 똑같은 메소드가있어도 됨 단, 선언부의 타입을 같게 해줘야 된다.
어레이 리스트를 사용할때 List만 사용하면된다. -> List(인터페이스임)와 ArrayList는 타입이 다른데 되면 상속관계이다.
어레이는 배열로 처리 링키드는 객체로 처리
수정이 많을때는 Linked list 로 하는게 좋고 Array List는 그냥 값을 읽을때 좋다.
ArrayList<> -> <>를 제네릭이라고 한다. <타입> - 타입을 고정시켜서 타입에 맞는것만 나온다.
list.add() 값을 넣어준다.
list.get() 값을 표현해준다.
list.size() 값의 길이를 나타내준다.
list.remove() -> 배열을 삭제 하면서 ()안의 값을 리턴해준다.
list.contains() -> List에 특정 값이 포함되어 있는지 확인해준다.
아규먼트 -> 파라미터 안에 전달해주는 값

instanceof는 if문에서 사용하면 좋다.

try{} 예외가 발생될 가능성이 있는 로직(source) 위치
catch(){} 예외가 발생되었을 때 하고 싶은 작업(로직) 위치 ,에러가 발생한것을 보고 싶으면 printStackTrace() 사용하면 됨
finally{} 옵션, 예외가 발생이 되든 안되든 무조건 실행하고 싶은 로직 위치
(Exception e) { // 왠만하면 제일밑에 적어주면 좋다. finally앞에 써주거나 제일 밑에 있어야 한다.
e.getMessage() 은 정말 Exception의 유형도 없이 정말 간단하게 왜 에러가 발생하였는지 보여주기만 합니다.

toString은 오브젝트에 있는 것이다.
String.format("");
-- 보충

객체>필드,메소드
멤버필드 > 값저장
메소드> 동작
생성자와 메소드의 다른점
클래스 이름과 생성자이름은 같아야 한다.
생성자는 리턴타입이 있으면 안됨!
this는 나자신의 객체주소값이 들어가는 것이다. 
인터페이스는 추상클래스만 넣을 수 있음.
추상클래스는 구현부가 없는 메소드와 있는 메소드 다만들수있음

--5/24
IoC(제어 반전)이란, 객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것을 의미합니다. , 기존의 방식에서 메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라, 외부에서 결정되는 것 
권한을 이전시켜서 수정에 용이하게 한다. 객체생성을 역으로 하여서 한번에 수정 가능하게 하는것
ioc에서 TvFactory 클래스는 제어를 위한 외부클래스 개념이다.

스프링에서는 에너테이션(@) 으로 구현을 해놓았다. -> 빈등록
